@using CardanoSharp.Wallet.Models;
@using CardanoSharp.Wallet.Models.Transactions;
@using CardanoSharp.Wallet.Extensions.Models.Transactions;
@using Microsoft.JSInterop;
@using CardanoSharp.Blazor.Components.Models;
@using CardanoSharp.Blazor.Components.Extensions;
@using CardanoSharp.Blazor.Components.Exceptions;
@using CardanoSharp.Blazor.Components.Enums;
@using CardanoSharp.Wallet.Extensions;
@using CardanoSharp.Wallet.Extensions.Models;
@using CardanoSharp.Wallet.Enums;
@using CardanoSharp.Wallet.Models.Addresses;
@using CardanoSharp.Blazor.Components.Utils;
@using CardanoSharp.Blazor.Components.ViewModels
@using PeterO.Cbor2;

@inject IJSRuntime JS
@inject Blazored.LocalStorage.ILocalStorageService _localStorage

@if (WalletConnectorButtonContent is not null && WalletsModalContent is not null)
{
    @WalletConnectorButtonContent(new WalletButtonViewModel(Connected, _connectedWallet))
    @WalletsModalContent(new WalletsModalContentViewModel(Initialized, _wallets, Connected, _connectedWallet, ConnectWalletAsync, DisconnectWalletAsync))
}
else
{
    <div class="wallet-connector">

        @if (!Connected)
        {
            <div class="wallet-connector-button" @onclick="ShowConnectWalletDialog" disabled="@IsDisconnectedButtonDisabled">@DisconnectedButtonContent</div>
        }
        else
        {
            <div class="wallet-connector-button" @onclick="ShowConnectWalletDialog">Connected<img class="wallet-icon" src="@_connectedWallet!.Icon" title="@_connectedWallet.Name" /></div>
        }

        @if (_showPopup)
        {
            <div id="myModal" class="modal" onclick="@(() => ModalClick())">
                <!-- Modal content -->
                <div class="modal-content" @onclick:stopPropagation="true">
                    <span class="close" @onclick="HideConnectWalletDialog">&times;</span>
                    <div class="modal-content-main">
                        @if (Initialized && _wallets != null)
                        {
                            @if (Connected && _connectedWallet != null)
                            {
                                <div class="wallet-card">
                                    <span class="wallet-card-title">@_connectedWallet.Name Wallet</span>
                                    <img class="wallet-card-icon" src="@_connectedWallet.Icon" title="@_connectedWallet.Name"/>
                                    <div class="wallet-balance-container">
                                        <div class="wallet-balance-row dif centered">
                                            <span class="wallet-balance-header">Balance</span>
                                        </div>
                                        <div class="wallet-balance-row dif centered">
                                            <span class="wallet-network">@_connectedWallet.Network</span>
                                        </div>
                                        <div class="wallet-balance-row wallet-available">
                                            <span>Available</span>
                                            <div class="wallet-adaamount-container">
                                                <span class="wallet-balance-ada">@_connectedWallet.BalanceAda</span>
                                                <span class="wallet-balance-decimal">.</span>
                                                <span class="wallet-balance-lovelace">@_connectedWallet.BalanceRemainder</span>
                                                <span class="wallet-balance-currency">@_connectedWallet.CoinCurrency</span>
                                            </div>
                                        </div>
                                        <div class="wallet-balance-row wallet-unavailable">
                                            <span>Reserved</span>
                                            <div class="wallet-adaamount-container">
                                                <span class="wallet-balance-ada">@_connectedWallet.TokenPreservationAda</span>
                                                <span class="wallet-balance-decimal">.</span>
                                                <span class="wallet-balance-lovelace">@_connectedWallet.TokenPreservationRemainder</span>
                                                <span class="wallet-balance-currency">@_connectedWallet.CoinCurrency</span>
                                            </div>
                                        </div>
                                        <div class="wallet-balance-row dif centered">
                                            <span>Collectibles @_connectedWallet.TokenCount</span>
                                        </div>
                                    </div>
                                    <button class="wallet-button" @onclick="@(async () => await DisconnectWalletAsync())">Disconnect</button>
                                </div>
                            }
                            else
                            {
                                @if (Layout == WalletConnectorLayout.List)
                                {
                                    <div class="wallet-choose-header">
                                        @Header
                                    </div>
                                    @foreach (var extension in _wallets)
                                    {
                                        <div class="wallet-item">
                                            <img class="wallet-icon" src="@extension.Icon" title="@extension.Name"/>
                                            <span class="wallet-name">@extension.Name Wallet</span>
                                            @if (extension.Installed)
                                            {
                                                <button disabled="@_connecting" class="@(_connecting ? "wallet-button-disabled" : "wallet-button")" @onclick="@(async () => await ConnectWalletAsync(extension.Key))">Connect</button>
                                            }
                                            else
                                            {
                                                <a class="wallet-button" href="@extension.Url" target="_blank">Install</a>
                                            }
                                        </div>
                                    }
                                }
                                else
                                {
                                    <div class="wallet-choose-header">
                                        @Header
                                    </div>
                                    <div class="wallet-card-container">
                                        @foreach (var extension in _wallets)
                                        {
                                            <div class="wallet-card">
                                                <span class="wallet-card-title">@extension.Name Wallet</span>
                                                <img class="wallet-card-icon" src="@extension.Icon" title="@extension.Name"/>
                                                @if (extension.Installed)
                                                {
                                                    <button disabled="@_connecting" class="@(_connecting ? "wallet-button-disabled" : "wallet-button")" @onclick="@(async () => await ConnectWalletAsync(extension.Key))">Connect</button>
                                                }
                                                else
                                                {
                                                    <a class="wallet-button" href="@extension.Url" target="_blank">Install</a>
                                                }
                                            </div>
                                        }
                                    </div>
                                }
                            }
                        }
                        else
                        {
                            <div>
                                <span>Looking for installed wallet extensions...</span>
                            </div>
                        }
                    </div>
                </div>
            </div>
        }
    </div>
}

@code {
    private const string _connectedWalletKey = "connectedWalletKey";

    [Parameter]
    public bool PersistConnectedWallet { get; set; }
    [Parameter]
    public bool OutputDebug { get; set; }
    [Parameter]
    public string Header { get; set; } = "Choose Your Wallet";
    [Parameter]
    public bool AutoCloseOnConnect { get; set; }
    [Parameter]
    public bool AutoCloseOnDisconnect { get; set; }
    [Parameter]
    public bool HideOnModalClick { get; set; } = true;
    [Parameter]
    public List<WalletExtension> SupportedExtensions { get; set; } = new List<WalletExtension>()
    {
        new WalletExtension() { 
            Key = "eternl", 
            Name = "Eternl", 
            Icon = WalletIcons.EternlIcon, 
            Url = "https://eternl.io" 
        },
        new WalletExtension() { 
            Key = "gerowallet", 
            Name = "Gero", 
            Icon = WalletIcons.GeroIcon, 
            Url = "https://gerowallet.io" 
        },
        new WalletExtension() { 
            Key = "nami", 
            Name = "Nami", 
            Icon = WalletIcons.NamiIcon, 
            Url = "https://namiwallet.io" 
        },
    };
    [Parameter]
    public WalletConnectorLayout Layout { get; set; } = WalletConnectorLayout.Card;
    [Parameter]
    public EventCallback OnConnectStart { get; set; }
    [Parameter]
    public EventCallback OnConnect { get; set; }
    [Parameter]
    public EventCallback<Exception> OnConnectError { get; set; }
    [Parameter]
    public EventCallback OnDisconnect { get; set; }
    [Parameter]
    public RenderFragment<WalletButtonViewModel> WalletConnectorButtonContent { get; set; } = null!;
    [Parameter]
    public RenderFragment<WalletsModalContentViewModel> WalletsModalContent { get; set; } = null!;

    private List<WalletExtensionState>? _wallets = new List<WalletExtensionState>();
    private DotNetObjectReference<WalletConnector>? _selfReference;
    private WalletExtensionState? _connectedWallet;
    private WalletConnectorJsInterop? _walletConnectorJs;
    private bool _connecting;
    private bool _showPopup;

    protected string DisconnectedButtonContent = "Initializing...";
    protected bool IsDisconnectedButtonDisabled = true;

    public bool Initialized { get; private set; }
    public bool Connected
    {
        get
        {
            return _connectedWallet != null;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        if (_walletConnectorJs == null)
        {
            _walletConnectorJs = new WalletConnectorJsInterop(JS);
        }
        //check which wallets are installed
        //set up initial _wallets state from above
        _selfReference = DotNetObjectReference.Create(this);
        _wallets = await _walletConnectorJs.Init(SupportedExtensions, _selfReference);

        Initialized = true;

        await InitializePersistedWalletAsync();

        if (!Connected)
        {
            DisconnectedButtonContent = "Connect";
            IsDisconnectedButtonDisabled = false;
        }

        return;
    }

    private async Task InitializePersistedWalletAsync()
    {
        if (!PersistConnectedWallet) { return; }

        var supportedWalletKeys = SupportedExtensions?.Select(s => s.Key)?.ToArray();

        if (supportedWalletKeys != null && supportedWalletKeys.Length > 0)
        {
            var storedWalletKey = await GetStoredWalletKeyAsync(supportedWalletKeys);

            if (!string.IsNullOrWhiteSpace(storedWalletKey))
            {
                if (!await ConnectWalletAsync(storedWalletKey, false))
                {
                    await RemoveStoredWalletKeyAsync();
                }
            }
        }

        StateHasChanged();
    }

    private async Task<string> GetStoredWalletKeyAsync(params string[] supportedWalletKeys)
    {
        var result = string.Empty;

        try
        {
            if (_localStorage != null && supportedWalletKeys != null)
            {
                var walletKey = await _localStorage.GetItemAsStringAsync(_connectedWalletKey);

                if (!string.IsNullOrWhiteSpace(walletKey) && supportedWalletKeys.Any(w => w.Equals(walletKey, StringComparison.OrdinalIgnoreCase)))
                {
                    result = walletKey;
                }
            }
        }
        catch (Exception err)
        {
            Console.WriteLine(err.Message);
        }

        return result;
    }

    private async Task SetStoredWalletKeyAsync(string walletKey)
    {
        if (PersistConnectedWallet && _localStorage != null && !string.IsNullOrWhiteSpace(walletKey))
        {
            await _localStorage.SetItemAsStringAsync(_connectedWalletKey, walletKey.ToString());
        }
    }

    private async Task RemoveStoredWalletKeyAsync()
    {
        if (PersistConnectedWallet && _localStorage != null)
        {
            await _localStorage.RemoveItemAsync(_connectedWalletKey);
        }
    }

    private void ModalClick()
    {
        Debug("MODAL CLICK");
        if (HideOnModalClick)
        {
            HideConnectWalletDialog();
        }
    }

    private void Debug(string text)
    {
        if (OutputDebug)
        {
            Console.WriteLine(text);
        }
    }

    public async ValueTask RefreshConnectedWallet()
    {
        var balance = await GetBalance();
        if (balance != null)
        {
            _connectedWallet!.TokenCount = 0;
            _connectedWallet.TokenPreservation = 0;
            if (balance.MultiAsset != null && balance.MultiAsset.Count > 0)
            {
                _connectedWallet.TokenPreservation = balance.MultiAsset.CalculateMinUtxoLovelace();
                _connectedWallet.TokenCount = balance.MultiAsset.Sum(x => x.Value.Token.Keys.Count);
            }
            _connectedWallet.Balance = balance.Coin - _connectedWallet.TokenPreservation;
        }
        _connectedWallet!.Network = await GetNetworkType();
        StateHasChanged();
    }

    public async ValueTask<bool> ConnectWalletAsync(string walletKey, bool suppressEvent = false)
    {
        try
        {
            if (!suppressEvent)
                _ = OnConnectStart.InvokeAsync().ConfigureAwait(false);

            _connecting = true;
            StateHasChanged();

            var result = await _walletConnectorJs!.ConnectWallet(walletKey);
            if (result)
            {
                _connectedWallet = _wallets!.First(x => x.Key == walletKey);
                await RefreshConnectedWallet();
                _wallets!.First(x => x.Key == walletKey).Connected = true;

                await SetStoredWalletKeyAsync(walletKey);

                if (AutoCloseOnConnect)
                {
                    _showPopup = false;
                }
            }
            if (!suppressEvent)
                _ = OnConnect.InvokeAsync();
            return result;
        }
        //suppress all errors as it could be valid user refusal 
        //(cant get enough detail out of gero wallet to ensure specific handling)
        catch (ErrorCodeException ecex)
        {
            Debug("Caught error code exception: " + ecex.Code + " - " + ecex.Info);
            _ = OnConnectError.InvokeAsync(ecex);
        }
        catch (PaginateException pex)
        {
            Debug("Caught paginate exception: " + pex.MaxSize);
            _ = OnConnectError.InvokeAsync(pex);
        }
        catch (WebWalletException wex)
        {
            Debug("Caught web wallet exception: " + wex.Data.Keys.ToString());
            _ = OnConnectError.InvokeAsync(wex);
        }
        catch (Exception ex)
        {
            Debug("Caught exception: " + ex.Message);
            _ = OnConnectError.InvokeAsync(ex);
        }
        finally
        {
            _connecting = false;
            StateHasChanged();
        }
        return false;
    }

    public async ValueTask DisconnectWalletAsync(bool suppressEvent = false)
    {
        await _walletConnectorJs!.Disconnect();
        while (_wallets!.Any(x => x.Connected))
        {
            _wallets!.First(x => x.Connected).Connected = false;
        }
        _connectedWallet = null;

        await RemoveStoredWalletKeyAsync();

        if (AutoCloseOnDisconnect)
        {
            _showPopup = false;
        }
        if (!suppressEvent)
            await OnDisconnect.InvokeAsync();
        return;
    }

    private void CheckInitializedAndConnected()
    {
        if (!Initialized || _walletConnectorJs == null)
        {
            throw new InvalidOperationException("Component not initialized");
        }
        if (!Connected)
        {
            throw new InvalidOperationException("No wallet connected");
        }
    }

    public void ShowConnectWalletDialog()
    {
        if (Connected)
        {
            _ = RefreshConnectedWallet();
        }
        _showPopup = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void HideConnectWalletDialog()
    {
        _showPopup = false;
        StateHasChanged();
    }

    public async ValueTask<NetworkType> GetNetworkType()
    {
        var networkId = await GetNetworkTypeId();
        return ComponentUtils.GetNetworkType(networkId);
    }

    public async ValueTask<int> GetNetworkTypeId()
    {
        CheckInitializedAndConnected();
        var networkId = await _walletConnectorJs!.GetNetworkId();
        Debug($"NETWORK ID: {networkId}");
        return networkId;
    }

    public async ValueTask<Utxo[]> GetUtxos(TransactionOutputValue? requiredOutput = null, Paginate? paginate = null)
    {
        string? amountCbor = null;
        if (requiredOutput != null)
        {
            amountCbor = requiredOutput.Serialize().ToStringHex();
        }
        var utxoCbors = await GetUtxosCbor(amountCbor, paginate);
        var utxoList = new List<Utxo>();
        foreach (var utxoCbor in utxoCbors)
        {
            utxoList.Add(utxoCbor.HexToByteArray().DeserializeUtxo());
        }
        return utxoList.ToArray();
    }

    public async ValueTask<string[]> GetUtxosCbor(string? requiredOutputCbor = null, Paginate? paginate = null)
    {
        CheckInitializedAndConnected();
        var utxoCbors = await _walletConnectorJs!.GetUtxos(requiredOutputCbor, paginate);
        foreach (var utxoCbor in utxoCbors)
        {
            Debug($"UTXO CBOR: {utxoCbor}");
        }
        return utxoCbors;
    }

    public async ValueTask<Utxo[]> GetCollateral(CollateralParams collateralParams)
    {
        var utxoCbors = await GetCollateralCbor(collateralParams);
        var utxoList = new List<Utxo>();
        foreach (var utxoCbor in utxoCbors)
        {
            utxoList.Add(utxoCbor.HexToByteArray().DeserializeUtxo());
        }
        return utxoList.ToArray();
    }

    public async ValueTask<string[]> GetCollateralCbor(CollateralParams collateralParams)
    {
        CheckInitializedAndConnected();
        var utxoCbors = await _walletConnectorJs!.GetCollateral(collateralParams);
        foreach (var utxoCbor in utxoCbors)
        {
            Debug($"COLLATERAL CBOR: {utxoCbor}");
        }
        return utxoCbors;
    }

    public async ValueTask<TransactionOutputValue> GetBalance()
    {
        var result = await GetBalanceCbor();
        var cborObj = CBORObject.DecodeFromBytes(result.HexToByteArray());
        if (cborObj.Type == CBORType.Integer)
        {
            var number = cborObj.AsNumber();
            var coin = number.ToUInt64Checked();
            return new TransactionOutputValue() { Coin = coin };
        }

        var outputValue = result.HexToByteArray().DeserializeTransactionOutputValue();
        return outputValue;
    }

    public async ValueTask<string> GetBalanceCbor()
    {
        CheckInitializedAndConnected();
        var result = await _walletConnectorJs!.GetBalance();
        Debug($"BALANCE CBOR: {result}");
        return result;
    }

    public async ValueTask<Address[]> GetUsedAddresses(Paginate? paginate = null)
    {
        CheckInitializedAndConnected();
        var addresses = await GetUsedAddressesHex(paginate);
        var response = new List<Address>();
        foreach (var address in addresses)
        {
            response.Add(new Address(ComponentUtils.GetPrefix(AddressType.Base, _connectedWallet!.Network), address.HexToByteArray()));
        }
        return response.ToArray();
    }

    public async ValueTask<string[]> GetUsedAddressesHex(Paginate? paginate = null)
    {
        CheckInitializedAndConnected();
        var addresses = await _walletConnectorJs!.GetUsedAddresses(paginate);
        foreach (var address in addresses)
        {
            Debug($"USED ADDRESS: {address}");
        }
        return addresses;
    }

    public async ValueTask<Address[]> GetUnusedAddresses()
    {
        var addresses = await GetUnusedAddressesHex();
        var response = new List<Address>();
        foreach (var address in addresses)
        {
            Debug($"UNUSED ADDRESS: {address}");
            response.Add(new Address(ComponentUtils.GetPrefix(AddressType.Base, _connectedWallet!.Network), address.HexToByteArray()));
        }
        return response.ToArray();
    }

    public async ValueTask<string[]> GetUnusedAddressesHex()
    {
        CheckInitializedAndConnected();
        var addresses = await _walletConnectorJs!.GetUnusedAddresses();
        foreach (var address in addresses)
        {
            Debug($"UNUSED ADDRESS: {address}");
        }
        return addresses;
    }

    public async ValueTask<Address> GetChangeAddress()
    {
        var address = await GetChangeAddressHex();
        return new Address(ComponentUtils.GetPrefix(AddressType.Base, _connectedWallet!.Network), address.HexToByteArray());
    }

    public async ValueTask<string> GetChangeAddressHex()
    {
        CheckInitializedAndConnected();
        var address = await _walletConnectorJs!.GetChangeAddress();
        Debug($"CHANGE ADDRESS: {address}");
        return address;
    }

    public async ValueTask<Address[]> GetRewardAddresses()
    {
        var addresses = await GetRewardAddressesHex();
        var response = new List<Address>();
        foreach (var address in addresses)
        {
            response.Add(new Address(ComponentUtils.GetPrefix(AddressType.Reward, _connectedWallet!.Network), address.HexToByteArray()));
        }
        return response.ToArray();
    }

    public async ValueTask<string[]> GetRewardAddressesHex()
    {
        CheckInitializedAndConnected();
        var addresses = await _walletConnectorJs!.GetRewardAddresses();
        foreach (var address in addresses)
        {
            Debug($"REWARD ADDRESS: {address}");
        }
        return addresses;
    }

    public async ValueTask<string> SignTx(Transaction tx, bool partialSign = false)
    {
        var txCbor = tx.Serialize().ToStringHex();
        return await SignTxCbor(txCbor, partialSign);
    }

    public async ValueTask<string> SignTxCbor(string txCbor, bool partialSign = false)
    {
        CheckInitializedAndConnected();
        Debug($"TX CBOR: {txCbor}");
        return await _walletConnectorJs!.SignTx(txCbor, partialSign);
    }

    public async ValueTask<DataSignature> SignData(string address, string hexData)
    {
        CheckInitializedAndConnected();
        return await _walletConnectorJs!.SignData(address, hexData);
    }

    public async ValueTask<string> SubmitTx(Transaction tx)
    {
        var txCbor = tx.Serialize().ToStringHex();
        return await SubmitTxCbor(txCbor);
    }

    public async ValueTask<string> SubmitTxCbor(string txCbor)
    {
        CheckInitializedAndConnected();
        Debug($"TX CBOR: {txCbor}");
        return await _walletConnectorJs!.SubmitTx(txCbor);
    }
}